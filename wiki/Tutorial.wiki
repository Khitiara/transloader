=The Problem=

Suppose you have one object, built using [http://java.sun.com/j2se/1.3/docs/api/java/lang/ClassLoader.html Class]es loaded through one [http://java.sun.com/j2se/1.3/docs/api/java/lang/ClassLoader.html ClassLoader], and another object, built using `Class`es loaded through a `ClassLoader` that is _independent_ of the first `ClassLoader`, and you want the two objects to interact:

[http://transloader.googlecode.com/svn/wiki/images/ClassLoaderClash.png]

This scenario does not occur very often in normal Java^TM^ development. However, it does occur whenever a container you are using implements `ClassLoader` isolation and yet that isolation needs to be crossed for whatever reason. For example, with [http://www.osgi.org OSGi], which provides `ClassLoader` isolation for each Bundle (a module in the OSGi Framework), valid reasons for crossing the `ClassLoader` divide include:

 # You have an object from a Bundle in the OSGi Framework that you want to use _outside_ the OSGi Framework.
 # You need to work around the situation where a particular combination of Bundle constraints makes it impossible for the OSGi Framework to make the Class space consistent.

The interaction between two Objects in the scenario above faces two potential problems:
 # !ClassLoader1 doesn’t even have access to the same `Class` definitions as !ClassLoader2
  * Effect: You cannot even compile the `Class` of ObjectA to reference the `Class` of ObjectB in the first place.
  * Workaround: You could use [http://java.sun.com/j2se/1.3/docs/guide/reflection/index.html JavaTM’s Reflection API] to call methods on ObjectB but this can be difficult and is always ugly.
 # !ClassLoader1 has access to the same `Class` definitions as !ClassLoader2 but loads them independently
  * Effect: You can compile the `Class` of ObjectA to reference the `Class` of ObjectB but when you bring the objects into contact (e.g. by passing one into the other through a reflective method invocation, or pulling one out of a [http://java.sun.com/j2se/1.3/docs/api/java/util/Collection.html Collection] accessible to the other and casting it) then a [http://java.sun.com/j2se/1.3/docs/api/java/lang/ClassCastException.html ClassCastException] will be thrown. This is because although ObjectB appears to extend/implement a type known to ObjectA, it really extends/implements a different copy of that type loaded by a different `ClassLoader`, not the copy of the type known to ObjectA.
  * Workaround: Again, don’t use ObjectB directly but either invoke its methods reflectively, with all the drawbacks that go with Java^TM^'s Reflection API, or use [http://java.sun.com/j2se/1.3/docs/guide/serialization/index.html JavaTM's Serialization API] to serialize ObjectB and deserialize it using !ClassLoader1. The latter workaround has the advantage of making a copy of ObjectB that will work in [http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#equals(java.lang.Object) Object#equals(Object)] and so forth but is slow and only works for object graphs that are completely [http://java.sun.com/j2se/1.3/docs/api/java/io/Serializable.html Serializable].

=The Solution=

Transloader aims to provide superior alternatives to the workarounds above.

The central interface is [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/Transloader.html com.googlecode.transloader.Transloader] and for convenience it provides static access to the default implementation via the [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/Transloader.html#DEFAULT Transloader.DEFAULT] constant (but you can use whatever implementation you want, which you'll usually want to inject following IOC). The `Transloader` interface is used to wrap objects referencing `Class`es from potentially foreign `ClassLoader`s like so:
{{{
Object someObject = someService.getObjectFromAnotherClassLoader();
Transloader transloader = Transloader.DEFAULT;
ObjectWrapper someObjectWrapped = transloader.wrap(someObject);
ClassWrapper someClassWrapped = transloader.wrap(someObject.getClass());
}}}

The resulting wrappers can then be used to work with the wrapped object despite the wrapped object referencing different `Class`es to those loaded by the `ClassLoader` of the calling code.

The [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/ClassWrapper.html ClassWrapper] is fairly self-explanatory; of more interest is the [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/ObjectWrapper.html ObjectWrapper]. `ObjectWrapper` basically provides the ability to clone the wrapped object in a way far superior to serialization or to invoke methods on the wrapped object without resorting directly to Java^TM^’s Reflection API. It also provides the ability to find out about the wrapped before doing either:
{{{
if (someObjectWrapped.isNull()) …
}}}
will let you handle the null case while
{{{
if (someObjectWrapped.isInstanceOf(“com.somepackage.SomeType”)) …
}}}
will let you handle particular types of object, analogous to
{{{
if (someObject instanceOf SomeType)) …
}}}
except that the [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/ObjectWrapper.html#isInstanceOf(java.lang.String) isInstanceOf] method takes a [http://java.sun.com/j2se/1.3/docs/api/java/lang/String.html String], not a `Class`, to indicate that it is only matching the wrapped object against a type name which could actually be loaded by any `ClassLoader` (whereas a `Class` refers to a specific `ClassLoader`) and in fact a definition of that type need not even be accessible to the `ClassLoader` of the calling object.

==Cloning==
If you want a copy of the wrapped object that will behave _exactly_ as if it were originally constructed using `Class`es from the current `ClassLoader`, the [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/ObjectWrapper.html#cloneWith(java.lang.ClassLoader) cloneWith] method is your friend:
{{{
if (someObjectWrapped.isInstanceOf(“com.somepackage.SomeType”)) {
    SomeType someObject = (SomeType) someObjectWrapped.cloneWith(getClass().getClassLoader());
    if (someOtherObject.equals(someObject) …
}
}}}
This is helpful when you are interested in the _values_ of the object from a foreign `ClassLoader`, not in that precise `Object` itself. It is perfectly compatible, for example, with being passed into the `Object#equals(Object)` method because it is built using local `Class`es. Of course, this can only solve Problem 2 above, where the relevant `Class`es are accessible to both `ClassLoader`s, not Problem 1 where the current `ClassLoader` cannot even access definitions of the `Class`es in the foreign `ClassLoader`.

The algorithm used to create the clone is supplied by the [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/clone/CloningStrategy.html CloningStrategy] injected into the `ObjectWrapper` at [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/ObjectWrapper.html#ObjectWrapper(java.lang.Object,%20com.googlecode.transloader.clone.CloningStrategy) construction], which in turn can be supplied by the particular implementation of `Transloader` that you choose to use. You can change the `CloningStrategy` by replacing the implementation of `Transloader` that you are using:
{{{
Transloader transloader = new DefaultTransloader(CloningStrategy.MINIMAL);
}}}
Out of the box Transloader supplies two major implementations of `CloningStrategy`
 # [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/clone/SerializationCloningStrategy.html One] based on Java^TM^ Serialization, which is comparatively slow and limited only to Serializables, but has the advantage that Java^TM^ Serialization has at least been well understood for a long time.
 # [http://transloader.googlecode.com/svn/trunk/transloader/target/site/apidocs/com/googlecode/transloader/clone/reflect/ReflectionCloningStrategy.html One] based on Java^TM^ Reflection, which is comparatively fast and much more flexible.

