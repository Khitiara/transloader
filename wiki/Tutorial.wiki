=The Problem=

Suppose you have one object, built using [http://java.sun.com/j2se/1.3/docs/api/java/lang/ClassLoader.html Class]es loaded through one [http://java.sun.com/j2se/1.3/docs/api/java/lang/ClassLoader.html ClassLoader], and another object, built using `Class`es loaded through a `ClassLoader` that is _independent_ of the first `ClassLoader`, and you want the two objects to interact:

[http://transloader.googlecode.com/svn/wiki/images/ClassLoaderClash.png]

This scenario does not occur very often in normal Java^TM^ development. However, it does occur whenever a container you are using implements `ClassLoader` isolation and yet that isolation needs to be crossed for whatever reason. For example, with [http://www.osgi.org OSGi], which provides `ClassLoader` isolation for each Bundle (a module in the OSGi Framework), valid reasons for crossing the `ClassLoader` divide include:

 # You have an object from a Bundle in the OSGi Framework that you want to use _outside_ the OSGi Framework.
 # You need to work around the situation where a particular combination of Bundle constraints makes it impossible for the OSGi Framework to make the Class space consistent.

The interaction between two Objects in the scenario above faces two potential problems:
 # !ClassLoader1 doesn’t even have access to the same `Class` definitions as !ClassLoader2
  * Effect: You cannot even compile the `Class` of ObjectA to reference the `Class` of ObjectB in the first place
  * Workaround: You could use [http://java.sun.com/j2se/1.3/docs/api/java/lang/reflect/package-summary.html Java^TM^’s Reflection API] to call methods on ObjectB but this can be difficult and is always ugly
 # !ClassLoader1 has access to the same `Class` definitions as !ClassLoader2 but loads them independently
  * Effect: You can compile the `Class` of ObjectA to reference the `Class` of ObjectB but when you bring the objects into contact (e.g. by passing one into the other through a reflective method invocation, or pulling one out of a [http://java.sun.com/j2se/1.3/docs/api/java/util/Collection.html Collection] accessible to the other and casting it) then a [http://java.sun.com/j2se/1.3/docs/api/java/lang/ClassCastException.html ClassCastException] will be thrown. This is because although ObjectB appears to extend/implement a type known to ObjectA, it really extends/implements a different copy of that type loaded by a different `ClassLoader`, not the copy of the type known to ObjectA.
  * Workaround: Again, don’t use ObjectB directly but either invoke its methods reflectively, with all the drawbacks that go with Java^TM^'s Reflection API, or use [http://java.sun.com/j2se/1.3/docs/guide/serialization/spec/serialTOC.doc.html Java^TM^'s Serialization API] to serialize ObjectB and deserialize it using !ClassLoader1. The latter workaround has the advantage of making a copy of ObjectB that will work in [http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#equals(java.lang.Object) Object#equals(Object)] and so forth but is slow and only works for object graphs that are completely [http://java.sun.com/j2se/1.3/docs/api/java/io/Serializable.html Serializable].